/**
 * @file
 * Describes an ideal prefetcher running up to
 * 1000000000000 ticks for the 429.mcf benchmark.
 */

#ifndef __MEM_CACHE_PREFETCH_IDEAL_HH__
#define __MEM_CACHE_PREFETCH_IDEAL_HH__

#include <queue>
#include <string>
#include <unordered_map>
#include <vector>

#include "base/types.hh"
#include "mem/cache/prefetch/base.hh"
#include "mem/packet.hh"

namespace gem5
{
  struct IdealPrefetcherParams;

  namespace prefetch
  {

    class Ideal : public Base
    {
    protected:
      struct PriorityPacket
      {
        /** Time when this prefetch becomes ready */
        Tick tick;
        /** The memory packet generated by this prefetch */
        PacketPtr pkt;
        /** The priority of this prefetch */
        unsigned long long priority;

        /**
         * Constructor
         * @param t Time when this prefetch becomes ready
         * @param p PacketPtr with the memory request of the prefetch
         * @param prio This prefetch priority
         */
        PriorityPacket(Tick t, int32_t prio)
            : tick(t), pkt(nullptr),
              priority(prio)
        {
        }

        bool operator>(const PriorityPacket &that) const
        {
          return priority > that.priority;
        }
        bool operator<(const PriorityPacket &that) const
        {
          return priority < that.priority;
        }
        bool operator<=(const PriorityPacket &that) const
        {
          return !(*this > that);
        }

        /**
         * Create the associated memory packet
         * @param paddr physical address of this packet
         * @param blk_size block size used by the prefetcher
         * @param requestor_id Requestor ID of the access that generated
         * this prefetch
         * @param tag_prefetch flag to indicate if the packet needs to be
         *        tagged
         * @param t time when the prefetch becomes ready
         */
        void createPkt(Addr paddr, unsigned blk_size,
                       RequestorID requestor_id, Tick t);
      };

      struct Prediction
      {
        Tick time;
        Addr addr;
        bool miss = true;
      };

      std::vector<Prediction> predictions;

      /** How far ahead of the memory access to start prefetching.
       *
       * How many predictions ahead of the memory access to start prefetching.
       */
      const int distance;

      unsigned long long priority_counter = ULONG_LONG_MAX;

      std::priority_queue<PriorityPacket> pfq;

      size_t notifyIndex = 0;

      size_t hitCount = 0;

      void initializePredictions(const std::string &prediction_file);

    public:
      Ideal(const IdealPrefetcherParams &p);
      virtual ~Ideal();

      void notify(const CacheAccessProbeArg &acc,
                  const PrefetchInfo &pfi) override;

      PacketPtr getPacket() override;

      Tick nextPrefetchReadyTime() const override;
    };

  } // namespace prefetch
} // namespace gem5

#endif // __MEM_CACHE_PREFETCH_IDEAL_HH__
